[
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "yfinance",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yfinance",
        "description": "yfinance",
        "detail": "yfinance",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "RandomForestRegressor",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "SentimentIntensityAnalyzer",
        "importPath": "nltk.sentiment",
        "description": "nltk.sentiment",
        "isExtraImport": true,
        "detail": "nltk.sentiment",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "fetch_stock_data",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def fetch_stock_data(ticker, start_date, end_date):\n    stock_data = yf.download(ticker, start=start_date, end=end_date)\n    return stock_data\ndef calculate_technical_indicators(df):\n    df['SMA20'] = df['Close'].rolling(window=20).mean()\n    df['SMA50'] = df['Close'].rolling(window=50).mean()\n    delta = df['Close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "calculate_technical_indicators",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def calculate_technical_indicators(df):\n    df['SMA20'] = df['Close'].rolling(window=20).mean()\n    df['SMA50'] = df['Close'].rolling(window=50).mean()\n    delta = df['Close'].diff()\n    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()\n    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()\n    rs = gain / loss\n    df['RSI'] = 100 - (100 / (1 + rs))\n    return df\ndef plot_stock_data(df):",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "plot_stock_data",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def plot_stock_data(df):\n    fig = go.Figure()\n    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='OHLC'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA20'], name='SMA20'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA50'], name='SMA50'))\n    fig.update_layout(title='Stock Price and Moving Averages', xaxis_title='Date', yaxis_title='Price')\n    return fig\ndef prepare_data_for_model(df):\n    df['Date'] = df.index\n    df['Date'] = pd.to_datetime(df['Date'])",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "prepare_data_for_model",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def prepare_data_for_model(df):\n    df['Date'] = df.index\n    df['Date'] = pd.to_datetime(df['Date'])\n    df['Day'] = df['Date'].dt.day\n    df['Month'] = df['Date'].dt.month\n    df['Year'] = df['Date'].dt.year\n    df['Weekday'] = df['Date'].dt.weekday\n    features = ['Open', 'High', 'Low', 'Volume', 'SMA20', 'SMA50', 'RSI', 'Day', 'Month', 'Year', 'Weekday']\n    X = df[features]\n    y = df['Close']",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "train_random_forest_model",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def train_random_forest_model(X, y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n    model = RandomForestRegressor(n_estimators=100, random_state=42)\n    model.fit(X_train, y_train)\n    return model\ndef predict_next_day(model, last_data):\n    return model.predict(last_data)\ndef fetch_news(ticker):\n    # This is a placeholder. In a real app, you'd use a proper news API\n    url = f\"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY\"",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "predict_next_day",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def predict_next_day(model, last_data):\n    return model.predict(last_data)\ndef fetch_news(ticker):\n    # This is a placeholder. In a real app, you'd use a proper news API\n    url = f\"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()['articles']\n    return []\ndef analyze_sentiment(text):",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "fetch_news",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def fetch_news(ticker):\n    # This is a placeholder. In a real app, you'd use a proper news API\n    url = f\"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()['articles']\n    return []\ndef analyze_sentiment(text):\n    sia = SentimentIntensityAnalyzer()\n    return sia.polarity_scores(text)['compound']",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "analyze_sentiment",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def analyze_sentiment(text):\n    sia = SentimentIntensityAnalyzer()\n    return sia.polarity_scores(text)['compound']\ndef main():\n    st.title('NVIDIA Stock Analysis and Prediction')\n    ticker = st.sidebar.text_input('Stock Ticker', value='NVDA')\n    start_date = st.sidebar.date_input('Start Date', datetime.now() - timedelta(days=365))\n    end_date = st.sidebar.date_input('End Date', datetime.now())\n    df = fetch_stock_data(ticker, start_date, end_date)\n    df = calculate_technical_indicators(df)",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def main():\n    st.title('NVIDIA Stock Analysis and Prediction')\n    ticker = st.sidebar.text_input('Stock Ticker', value='NVDA')\n    start_date = st.sidebar.date_input('Start Date', datetime.now() - timedelta(days=365))\n    end_date = st.sidebar.date_input('End Date', datetime.now())\n    df = fetch_stock_data(ticker, start_date, end_date)\n    df = calculate_technical_indicators(df)\n    st.subheader('Stock Data')\n    st.dataframe(df.tail())\n    st.plotly_chart(plot_stock_data(df))",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    }
]