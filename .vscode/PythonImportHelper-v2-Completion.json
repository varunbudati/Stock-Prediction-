[
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "yfinance",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yfinance",
        "description": "yfinance",
        "detail": "yfinance",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "fetch_stock_data",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def fetch_stock_data(ticker, start_date, end_date):\n    stock_data = yf.download(ticker, start=start_date, end=end_date)\n    return stock_data\ndef calculate_technical_indicators(df):\n    df['SMA20'] = df['Close'].rolling(window=20).mean()\n    df['SMA50'] = df['Close'].rolling(window=50).mean()\n    return df\ndef plot_stock_data(df):\n    fig = go.Figure()\n    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='OHLC'))",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "calculate_technical_indicators",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def calculate_technical_indicators(df):\n    df['SMA20'] = df['Close'].rolling(window=20).mean()\n    df['SMA50'] = df['Close'].rolling(window=50).mean()\n    return df\ndef plot_stock_data(df):\n    fig = go.Figure()\n    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='OHLC'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA20'], name='SMA20'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA50'], name='SMA50'))\n    fig.update_layout(title='Stock Price and Moving Averages', xaxis_title='Date', yaxis_title='Price')",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "plot_stock_data",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def plot_stock_data(df):\n    fig = go.Figure()\n    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='OHLC'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA20'], name='SMA20'))\n    fig.add_trace(go.Scatter(x=df.index, y=df['SMA50'], name='SMA50'))\n    fig.update_layout(title='Stock Price and Moving Averages', xaxis_title='Date', yaxis_title='Price')\n    return fig\ndef predict_next_day(df):\n    last_price = df['Close'].iloc[-1]\n    sma20 = df['SMA20'].iloc[-1]",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "predict_next_day",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def predict_next_day(df):\n    last_price = df['Close'].iloc[-1]\n    sma20 = df['SMA20'].iloc[-1]\n    sma50 = df['SMA50'].iloc[-1]\n    if sma20 > sma50:\n        prediction = last_price * 1.01  # Predict 1% increase\n    else:\n        prediction = last_price * 0.99  # Predict 1% decrease\n    return prediction\ndef fetch_news(ticker):",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "fetch_news",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def fetch_news(ticker):\n    # This is a placeholder. In a real app, you'd use a proper news API\n    url = f\"https://newsapi.org/v2/everything?q={ticker}&apiKey=YOUR_API_KEY\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()['articles']\n    return []\ndef simple_sentiment_analysis(text):\n    positive_words = ['up', 'rise', 'gain', 'positive', 'good', 'increase', 'higher']\n    negative_words = ['down', 'fall', 'loss', 'negative', 'bad', 'decrease', 'lower']",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "simple_sentiment_analysis",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def simple_sentiment_analysis(text):\n    positive_words = ['up', 'rise', 'gain', 'positive', 'good', 'increase', 'higher']\n    negative_words = ['down', 'fall', 'loss', 'negative', 'bad', 'decrease', 'lower']\n    words = text.lower().split()\n    positive_count = sum(word in positive_words for word in words)\n    negative_count = sum(word in negative_words for word in words)\n    if positive_count > negative_count:\n        return 1\n    elif negative_count > positive_count:\n        return -1",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "streamlit_stockPredictor",
        "description": "streamlit_stockPredictor",
        "peekOfCode": "def main():\n    st.title('NVIDIA Stock Analysis and Prediction')\n    ticker = st.sidebar.text_input('Stock Ticker', value='NVDA')\n    start_date = st.sidebar.date_input('Start Date', datetime.now() - timedelta(days=365))\n    end_date = st.sidebar.date_input('End Date', datetime.now())\n    df = fetch_stock_data(ticker, start_date, end_date)\n    df = calculate_technical_indicators(df)\n    st.subheader('Stock Data')\n    st.dataframe(df.tail())\n    st.plotly_chart(plot_stock_data(df))",
        "detail": "streamlit_stockPredictor",
        "documentation": {}
    }
]